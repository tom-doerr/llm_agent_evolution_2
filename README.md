# LLM Agent Evolution

A framework for evolving LLM-based agents through evolutionary algorithms.

## Overview

This project implements an evolutionary algorithm for LLM-based agents. The system evolves agents with three chromosomes:
- **Task chromosome**: The output that gets evaluated for fitness
- **Mate selection chromosome**: Instructions for selecting mates
- **Mutation chromosome**: Instructions for how to mutate chromosomes

The system uses a continuous evolution process rather than discrete generations, with parent selection using a Pareto distribution weighted by fitness squared.

## Key Features

- **Chromosomes for Separation of Functionality**: Each agent has three chromosomes to separate different aspects of functionality
- **Evolutionary Approach**: Everything evolves, including combination and mate selection strategies
- **Easy Problem Application**: Can be run on any problem with a command-line evaluation interface
- **Information-Dense Output**: Provides concise but informative output
- **Detailed Logging**: Logs detailed information to a file
- **Parent Selection**: Uses Pareto distribution weighting by fitness^2 with weighted sampling
- **Population Statistics**: Includes mean, median, standard deviation for population rewards
- **Large Population Support**: Default population size limit of one million
- **LLM-Based Mutation**: Mutations are generated by LLMs with specific instructions
- **Mate Selection**: Uses LLM to select mates based on agent's mate selection chromosome
- **Chromosome Hotspots**: Mating combines chromosomes at hotspots (punctuation, spaces)
- **Hexagonal Architecture**: Clean separation of concerns with domain logic isolated from external systems
- **Multithreading Support**: Run multiple evolution threads in parallel
- **Mock LLM Support**: Test without making real API calls
- **Standalone Mode**: Run without LLM API calls for simple optimization tasks

## Installation

### Prerequisites

- Python 3.8+
- pip

### Basic Installation

```bash
# Clone the repository
git clone https://github.com/yourusername/llm_agent_evolution.git
cd llm_agent_evolution

# Install the package in development mode
pip install -e .

# Install with test dependencies
pip install -e ".[test]"
```

## Usage

### Quick Start

Run a quick test using the mock LLM adapter (no real API calls):

```bash
# Using the installed CLI tool
llm-evolve evolve --quick-test

# Or using the module directly
python -m llm_agent_evolution evolve --quick-test
```

### Main Evolution Process

Run the evolution process with a real LLM:

```bash
llm-evolve evolve --population-size 50 --parallel-agents 8 --model "openrouter/google/gemini-2.0-flash-001"
```

### Universal Optimizer

Run the universal optimizer with a custom evaluation command:

```bash
llm-evolve optimize "python examples/count_a.py" --population-size 50 --parallel-agents 8
```

### Standalone Optimizer (No LLM API Calls)

Run the simplified standalone optimizer that doesn't use LLM API calls:

```bash
llm-evolve standalone "python examples/count_a.py" --population-size 50 --parallel-agents 8
```

### Interactive Demo

Run an interactive step-by-step demo of the evolution process:

```bash
llm-evolve demo --use-mock
```

## How the Optimization Works

The system optimizes agents through an evolutionary process:

1. **Initialization**: Create a population of agents with empty chromosomes
2. **Evaluation**: Evaluate each agent's task chromosome to get a reward
3. **Parent Selection**: Select parents using Pareto distribution weighted by fitness^2
4. **Mating**: Combine chromosomes from parents at hotspots (punctuation, spaces)
5. **Mutation**: Use the agent's mutation chromosome as instructions for the LLM to modify it
6. **Population Management**: Add new agents to population, removing worst if size limit reached

The current implementation optimizes for a specific hidden goal: maximizing the number of 'a' characters in the first 23 positions, with penalties for exceeding 23 characters.

## Command Line Options

### Main Evolution Process

```
python -m llm_agent_evolution evolve [options]

Options:
  -p, --population-size INT    Initial population size (default: 100)
  -j, --parallel-agents INT    Number of agents to evaluate in parallel (default: 10)
  -n, --max-evaluations INT    Maximum number of evaluations to run (default: unlimited)
  -m, --model STRING           LLM model to use (default: openrouter/google/gemini-2.0-flash-001)
  -l, --log-file STRING        Log file path (default: evolution.log)
  --use-mock, --mock           Use mock LLM adapter for testing
  -s, --seed INT               Random seed for reproducibility
  -e, --eval-command STRING    Command to run for evaluation
  -q, --quick-test             Run a quick test with mock LLM
```

### Universal Optimizer

```
python -m llm_agent_evolution optimize EVAL_COMMAND [options]

Options:
  -p, --population-size INT    Initial population size (default: 50)
  -j, --parallel-agents INT    Number of agents to evaluate in parallel (default: 8)
  -n, --max-evaluations INT    Maximum number of evaluations to run (default: unlimited)
  -m, --model STRING           LLM model to use (default: openrouter/google/gemini-2.0-flash-001)
  -l, --log-file STRING        Log file path (default: universal_optimize.log)
  --use-mock-llm, --mock       Use mock LLM adapter for testing
  -s, --seed INT               Random seed for reproducibility
  -t, --script-timeout INT     Maximum execution time for the evaluation script (default: 30)
  -i, --initial-content STRING Initial content for the chromosomes
  -f, --initial-file FILE      File containing initial content for the chromosomes
  -o, --output-file FILE       File to write the best result to
  --output-format FORMAT       Output format: text or json (default: text)
  --max-chars INT              Maximum number of characters for chromosomes (default: 1000)
  -v, --verbose                Enable verbose mode with detailed output
```

### Standalone Optimizer

```
python -m llm_agent_evolution standalone EVAL_COMMAND [options]

Options:
  -p, --population-size INT    Initial population size (default: 50)
  -j, --parallel-agents INT    Number of agents to evaluate in parallel (default: 8)
  -n, --max-evaluations INT    Maximum number of evaluations to run (default: 1000)
  -i, --initial-content STRING Initial content for the chromosomes
  -s, --seed INT               Random seed for reproducibility
  -v, --verbose                Enable verbose output
  -o, --output-file FILE       File to write the best result to
```

## Architecture

The project follows a hexagonal (ports and adapters) architecture:

- **Domain**: Core entities and business logic
  - `model.py`: Agent and Chromosome classes
  - `services.py`: Evolution services like parent selection and mating

- **Ports**: Interface definitions
  - `primary.py`: Use case interfaces (evolution)
  - `secondary.py`: External system interfaces (LLM, logging, statistics)

- **Adapters**: Implementation of interfaces
  - Primary: CLI interface
  - Secondary: LLM, logging, statistics implementations

## Development

```bash
# Run tests
python -m pytest

# Run a specific test
python -m pytest tests/test_domain.py

# Run with coverage
python -m pytest --cov=llm_agent_evolution
```

## License

MIT
